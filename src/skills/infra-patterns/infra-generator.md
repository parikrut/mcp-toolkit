# Infrastructure Code Generator Pattern

## 1. Component Pattern

**Type:** Code Generation Script  
**Layer:** Infrastructure / Build Tooling  
**Reference Implementation:** `products/property-tax/infra/generate.ts`

## 2. Overview

The infrastructure generator is a TypeScript script (`generate.ts`) that reads the typed service registry and produces three auto-generated files:

1. **`apps/<product>-web/nginx.conf`** â€” A complete nginx reverse-proxy configuration that routes each API path prefix to the correct backend service, serves the SPA with history-mode fallback, and applies security headers + gzip compression.

2. **`products/<product>/infra/init-databases.sql`** â€” SQL script that creates one database per service (DB-per-service pattern) and grants privileges to the shared database user. Mounted into the PostgreSQL container via Docker Compose.

3. **`products/<product>/start-dev.sh`** â€” An executable shell script that starts the entire development stack with one command: runs `docker compose up`, polls health endpoints until all services are ready, and prints a summary of URLs (frontend, Swagger docs, infrastructure UIs).

Before generating any output, the script runs **validation** against the registry:

- No duplicate ports across services
- No duplicate API route prefixes across services
- All `extraEnv` values ending in `_URL` that start with `http://` must reference a valid hostname and port from the registry
- All `dependsOn` entries must reference valid registry keys

If validation fails, the script prints all errors and exits with code 1. No files are written.

All generated files include a header: `AUTO-GENERATED by infra/generate.ts â€” do not edit manually.` with a reference to the service registry as the source of truth. These files should be committed to git so they're available without running the generator, but must never be manually edited.

## 3. Rules

1. **Run after any registry change.** After adding, removing, or modifying a service in `service-registry.ts`, run `pnpm tsx infra/generate.ts`.
2. **Validation runs first.** The script must validate before generating. A validation failure aborts all generation.
3. **Port uniqueness is mandatory.** Two services with the same port is a fatal error.
4. **Route uniqueness is mandatory.** Two services claiming the same route prefix is a fatal error. Each route is owned by exactly one service.
5. **`extraEnv` URL validation.** Any environment variable ending in `_URL` with value `http://<hostname>:<port>` must match a registry entry's hostname and port exactly.
6. **`dependsOn` validation.** Every entry in a service's `dependsOn` array must be a valid key in the registry.
7. **Generated files have headers.** Every output file starts with a comment block: `AUTO-GENERATED by infra/generate.ts â€” do not edit manually.`
8. **Nginx routes are grouped by layer.** Platform routes first, then shared, then domain â€” matching the registry's layer annotations.
9. **SQL creates databases for services with non-empty `database` field.** Services with `database: ""` (e.g., API gateway) are skipped.
10. **Start-dev script uses health polling.** Each service is polled on its `/health` endpoint with a timeout of 60 iterations Ã— 2 seconds. Infrastructure services are polled first.
11. **Generated files are committed.** They're checked into git so CI/CD and other developers don't need to run the generator.
12. **Script paths are relative to monorepo root.** The script computes `ROOT` as `path.resolve(__dirname, "../../..")` to find the correct output directories.

## 4. Structure

```
products/<product-name>/
â”œâ”€â”€ infra/
â”‚   â”œâ”€â”€ service-registry.ts     # Input  â€” typed service definitions
â”‚   â”œâ”€â”€ generate.ts             # This script â€” reads registry, writes 3 files
â”‚   â””â”€â”€ init-databases.sql      # Output â€” auto-generated SQL
â”œâ”€â”€ start-dev.sh                # Output â€” auto-generated dev startup script
â””â”€â”€ ...

apps/<product-name>-web/
â””â”€â”€ nginx.conf                  # Output â€” auto-generated nginx config
```

**Data flow:**

```
service-registry.ts
        â”‚
        â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ generate.ts  â”‚
  â”‚              â”‚
  â”‚ 1. validate  â”‚
  â”‚ 2. generate  â”‚
  â”‚ 3. write     â”‚
  â””â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”˜
     â”‚   â”‚   â”‚
     â–¼   â–¼   â–¼
nginx.conf  init-databases.sql  start-dev.sh
```

**Validation checks:**

| Check                        | Scope        | Error Message                                                   |
| ---------------------------- | ------------ | --------------------------------------------------------------- |
| Duplicate port               | All services | `Port {N} used by both '{A}' and '{B}'`                         |
| Duplicate route              | All services | `Route '{R}' used by both '{A}' and '{B}'`                      |
| Unknown hostname in extraEnv | Per service  | `{key}.extraEnv.{var} references unknown hostname '{host}'`     |
| Port mismatch in extraEnv    | Per service  | `{key}.extraEnv.{var} port {N} doesn't match '{host}' port {M}` |
| Unknown dependsOn            | Per service  | `{key}.dependsOn references unknown service '{dep}'`            |

## 5. Example Implementation

```typescript
#!/usr/bin/env tsx
/**
 * â”€â”€â”€ Infrastructure Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Generates nginx.conf, init-databases.sql, and start-dev.sh
 * from the typed service registry. Run after modifying
 * service-registry.ts:
 *
 *   pnpm tsx infra/generate.ts
 *
 * Validates:
 *   â€¢ No duplicate ports
 *   â€¢ No duplicate API route prefixes
 *   â€¢ All extraEnv service URLs reference valid registry entries
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { serviceRegistry, type ServiceKey } from "./service-registry";

const ROOT = path.resolve(__dirname, "../../.."); // monorepo root
const PRODUCT_DIR = path.resolve(__dirname, ".."); // products/<product>
const NGINX_OUT = path.join(ROOT, "apps/product-web/nginx.conf");
const SQL_OUT = path.join(__dirname, "init-databases.sql");
const DEV_SH_OUT = path.join(PRODUCT_DIR, "start-dev.sh");

// â”€â”€â”€ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function validate(): void {
    const ports = new Map<number, string>();
    const routes = new Map<string, string>();
    const errors: string[] = [];

    for (const [key, svc] of Object.entries(serviceRegistry)) {
        // Duplicate port check
        if (ports.has(svc.port)) {
            errors.push(
                `Port ${svc.port} used by both '${ports.get(svc.port)}' and '${key}'`,
            );
        }
        ports.set(svc.port, key);

        // Duplicate route check
        for (const route of svc.routes) {
            if (routes.has(route)) {
                errors.push(
                    `Route '${route}' used by both '${routes.get(route)}' and '${key}'`,
                );
            }
            routes.set(route, key);
        }

        // Validate extraEnv service URLs reference known hostnames
        if (svc.extraEnv) {
            for (const [envKey, envVal] of Object.entries(svc.extraEnv)) {
                if (envKey.endsWith("_URL") && envVal.startsWith("http://")) {
                    const match = envVal.match(/^http:\/\/([^:]+):(\d+)$/);
                    if (match) {
                        const referencedHost = match[1];
                        const referencedPort = Number(match[2]);
                        const found = Object.values(serviceRegistry).find(
                            (s) => s.hostname === referencedHost,
                        );
                        if (!found) {
                            errors.push(
                                `${key}.extraEnv.${envKey} references unknown hostname '${referencedHost}'`,
                            );
                        } else if (found.port !== referencedPort) {
                            errors.push(
                                `${key}.extraEnv.${envKey} port ${referencedPort} doesn't match '${referencedHost}' port ${found.port}`,
                            );
                        }
                    }
                }
            }
        }

        // Validate dependsOn references
        if (svc.dependsOn) {
            for (const dep of svc.dependsOn) {
                if (!(dep in serviceRegistry)) {
                    errors.push(
                        `${key}.dependsOn references unknown service '${dep}'`,
                    );
                }
            }
        }
    }

    if (errors.length > 0) {
        console.error("âŒ Validation failed:\n");
        for (const e of errors) console.error(`  â€¢ ${e}`);
        process.exit(1);
    }

    console.log(
        `âœ… Validated ${ports.size} services, ${routes.size} routes â€” no conflicts`,
    );
}

// â”€â”€â”€ Nginx Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateNginxConf(): string {
    const proxyHeaders = [
        "proxy_set_header Host              $host;",
        "proxy_set_header X-Real-IP         $remote_addr;",
        "proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;",
        "proxy_set_header X-Forwarded-Proto $scheme;",
    ];

    function locationBlock(
        route: string,
        hostname: string,
        port: number,
    ): string {
        const lines = [
            `    location ${route} {`,
            `        proxy_pass http://${hostname}:${port};`,
            ...proxyHeaders.map((h) => `        ${h}`),
            `    }`,
        ];
        return lines.join("\n");
    }

    // Group services by layer for readability
    const layerOrder: Array<"platform" | "shared" | "domain"> = [
        "platform",
        "shared",
        "domain",
    ];
    const grouped = new Map<string, (typeof serviceRegistry)[ServiceKey][]>();

    for (const layer of layerOrder) {
        grouped.set(layer, []);
    }

    for (const svc of Object.values(serviceRegistry)) {
        grouped.get(svc.layer)!.push(svc);
    }

    const locationBlocks: string[] = [];

    for (const layer of layerOrder) {
        const services = grouped.get(layer)!;
        if (services.length === 0) continue;

        for (const svc of services) {
            locationBlocks.push(`    # ${svc.label} â€” :${svc.port}`);
            for (const route of svc.routes) {
                locationBlocks.push(
                    locationBlock(route, svc.hostname, svc.port),
                );
            }
            locationBlocks.push("");
        }
    }

    return `# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Product Web â€” Nginx reverse-proxy / SPA host
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AUTO-GENERATED by infra/generate.ts â€” do not edit manually.
# Source of truth: products/<product>/infra/service-registry.ts
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Gzip compression
gzip on;
gzip_vary on;
gzip_proxied any;
gzip_min_length 256;
gzip_comp_level 6;
gzip_types
    text/plain
    text/css
    text/javascript
    application/javascript
    application/json
    application/xml
    image/svg+xml;

server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # â”€â”€ Security headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    add_header X-Frame-Options            DENY always;
    add_header X-Content-Type-Options     nosniff always;
    add_header X-XSS-Protection           "1; mode=block" always;
    add_header Referrer-Policy            "strict-origin-when-cross-origin" always;
    add_header Permissions-Policy         "camera=(), microphone=(), geolocation=()" always;
    add_header Strict-Transport-Security  "max-age=31536000; includeSubDomains" always;
    add_header Content-Security-Policy    "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self' http://localhost:* ws://localhost:*;" always;

    # â”€â”€ SPA fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    location / {
        try_files $uri $uri/ /index.html;
    }

    # â”€â”€ Static asset caching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    location ~* \\.(?:js|css|woff2?|ttf|eot|svg|png|jpe?g|gif|ico|webp|avif)$ {
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
        access_log off;
    }

    # index.html â€” never cache
    location = /index.html {
        add_header Cache-Control "no-cache" always;
    }

    # â”€â”€ API proxying (auto-generated from service registry) â”€

${locationBlocks.join("\\n")}
}
`;
}

// â”€â”€â”€ SQL Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateInitSql(): string {
    const databases = Object.values(serviceRegistry)
        .filter((svc) => svc.database !== "")
        .map((svc) => svc.database);

    const creates = databases
        .map((db) => `CREATE DATABASE ${db};`)
        .join("\n");
    const grants = databases
        .map((db) => `GRANT ALL PRIVILEGES ON DATABASE ${db} TO civic;`)
        .join("\n");

    return `-- â”€â”€â”€ Product â€” Database Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO-GENERATED by infra/generate.ts â€” do not edit manually.
-- Source of truth: products/<product>/infra/service-registry.ts
--
-- Creates one database per module (DB-per-service pattern)

${creates}

-- Grant full access to the civic user
${grants}
`;
}

// â”€â”€â”€ Start-Dev Shell Script Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateStartDevSh(): string {
    const $ = "$"; // literal dollar sign for template literals

    // Backend services with databases (skip pure proxies)
    const backendServices = Object.values(serviceRegistry)
        .filter((svc) => svc.database !== "")
        .sort((a, b) => a.port - b.port);

    const servicesArrayEntries = backendServices
        .map((svc) => `    "${svc.port}:${svc.label}"`)
        .join("\n");

    const maxLabelLen = Math.max(
        ...backendServices.map((svc) => svc.label.length),
    );
    const swaggerLines = backendServices
        .map((svc) => {
            const pad = " ".repeat(maxLabelLen - svc.label.length);
            return `echo "  ${svc.label}:${pad} http://localhost:${svc.port}/swagger"`;
        })
        .join("\n");

    return `#!/usr/bin/env bash
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AUTO-GENERATED by infra/generate.ts â€” do not edit manually.
# Source of truth: products/<product>/infra/service-registry.ts
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
set -e

SCRIPT_DIR="${$}(cd "${$}(dirname "${$}{BASH_SOURCE[0]}")" && pwd)"
cd "${$}SCRIPT_DIR"

echo "ğŸ›ï¸  Civic Product â€” Development Environment"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

# Regenerate infra config from service registry
echo "âš™ï¸  Generating infrastructure config from service registry..."
npx tsx "${$}SCRIPT_DIR/infra/generate.ts"
echo ""

# Check Docker
if ! docker info >/dev/null 2>&1; then
    echo "âŒ Docker is not running. Please start Docker Desktop first."
    exit 1
fi

# Start full stack
echo "ğŸ³ Starting all services via Docker Compose..."
echo ""
docker compose up -d --build

echo ""
echo "â³ Waiting for services to become healthy..."

# Wait for infrastructure
for i in {1..30}; do
    POSTGRES_OK=${$}(docker compose ps postgres --format '{{.Status}}' 2>/dev/null | grep -c healthy || true)
    RABBITMQ_OK=${$}(docker compose ps rabbitmq --format '{{.Status}}' 2>/dev/null | grep -c healthy || true)
    REDIS_OK=${$}(docker compose ps redis --format '{{.Status}}' 2>/dev/null | grep -c healthy || true)
    if [[ "${$}POSTGRES_OK" -ge 1 && "${$}RABBITMQ_OK" -ge 1 && "${$}REDIS_OK" -ge 1 ]]; then
        echo "  âœ” Infrastructure ready (PostgreSQL, RabbitMQ, Redis)"
        break
    fi
    sleep 2
done

# Wait for backend services
SERVICES=(
${servicesArrayEntries}
)
echo "  â³ Waiting for backend services..."
for entry in "${$}{SERVICES[@]}"; do
    PORT="${$}{entry%%:*}"
    NAME="${$}{entry#*:}"
    for i in {1..60}; do
        if curl -sf "http://localhost:${$}PORT/health" >/dev/null 2>&1; then
            echo "  âœ” ${$}NAME (:${$}PORT)"
            break
        fi
        sleep 2
    done
done

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… All services running!"
echo ""
echo "  Frontend:          http://localhost:5173"
echo ""
${swaggerLines}
echo ""
echo "  Prisma Studio:     http://localhost:5555"
echo "  PostgreSQL:        localhost:5433  (civic / civic)"
echo "  RabbitMQ:          http://localhost:15673  (civic / civic)"
echo "  Redis:             localhost:6380"
echo ""
echo "Useful commands:"
echo "  docker compose logs -f           # Follow all logs"
echo "  docker compose logs <service>    # Logs for one service"
echo "  docker compose down              # Stop everything"
echo "  docker compose down -v           # Stop + delete volumes"
echo ""
`;
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

validate();

const nginx = generateNginxConf();
fs.writeFileSync(NGINX_OUT, nginx, "utf-8");
console.log(\`ğŸ“ Generated \${path.relative(ROOT, NGINX_OUT)}\`);

const sql = generateInitSql();
fs.writeFileSync(SQL_OUT, sql, "utf-8");
console.log(\`ğŸ“ Generated \${path.relative(ROOT, SQL_OUT)}\`);

const devSh = generateStartDevSh();
fs.writeFileSync(DEV_SH_OUT, devSh, { encoding: "utf-8", mode: 0o755 });
console.log(\`ğŸ“ Generated \${path.relative(ROOT, DEV_SH_OUT)}\`);

console.log("\\nDone. Commit the generated files.");
```

**Generated output examples:**

**`nginx.conf` â€” generated route block:**

```nginx
    # Auth Gateway â€” :4100
    location /api/v1/auth {
        proxy_pass http://auth-gateway:4100;
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/v1/users {
        proxy_pass http://auth-gateway:4100;
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
```

**`init-databases.sql` â€” generated output:**

```sql
-- â”€â”€â”€ Product â€” Database Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO-GENERATED by infra/generate.ts â€” do not edit manually.
-- Source of truth: products/<product>/infra/service-registry.ts
--
-- Creates one database per module (DB-per-service pattern)

CREATE DATABASE auth_gateway;
CREATE DATABASE notification_engine;
CREATE DATABASE audit_logging;
CREATE DATABASE billing_invoicing;
CREATE DATABASE resource_module;
CREATE DATABASE another_module;

-- Grant full access to the civic user
GRANT ALL PRIVILEGES ON DATABASE auth_gateway TO civic;
GRANT ALL PRIVILEGES ON DATABASE notification_engine TO civic;
GRANT ALL PRIVILEGES ON DATABASE audit_logging TO civic;
GRANT ALL PRIVILEGES ON DATABASE billing_invoicing TO civic;
GRANT ALL PRIVILEGES ON DATABASE resource_module TO civic;
GRANT ALL PRIVILEGES ON DATABASE another_module TO civic;
```

**Adapting for a new product:**

1. Create `products/<new-product>/infra/generate.ts`.
2. Update the path constants: `NGINX_OUT`, `SQL_OUT`, `DEV_SH_OUT` to reference the new product's directories.
3. Import from the new product's `service-registry.ts`.
4. The generator functions are product-agnostic â€” only the import path and output paths change.
5. Run: `pnpm tsx products/<new-product>/infra/generate.ts`.
