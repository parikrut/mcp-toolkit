# Database-Per-Service Architecture

## 1. Component Pattern

**Type:** Infrastructure / Data Architecture  
**Layer:** Platform / DevOps  
**Reference Implementation:** `products/property-tax/infra/service-registry.ts`, `products/property-tax/docker-compose.yml`, `products/property-tax/infra/init-databases.sql`

## 2. Overview

The civic-modules platform follows a strict **database-per-service** architecture: every microservice module that requires persistence owns its own isolated PostgreSQL database. No two modules ever share a database or read from each other's tables directly. Cross-module data access is accomplished exclusively through HTTP service clients.

In development, a single PostgreSQL 16 instance hosts multiple databases (one per module) for convenience. In production, each service can be backed by a fully independent PostgreSQL instance for maximum isolation, independent scaling, and fault tolerance.

The `service-registry.ts` file is the **single source of truth** for all service metadata, including the `database` field that specifies each service's PostgreSQL database name (in `snake_case`). An infrastructure generator script (`infra/generate.ts`) reads the service registry and auto-generates:

- **`init-databases.sql`** — A SQL script that creates all databases and grants privileges, mounted as a Docker entrypoint script so databases are provisioned automatically when the PostgreSQL container starts.
- **`docker-compose.yml`** service definitions — Each backend service receives a `DATABASE_URL` environment variable pointing to its own database.
- **`start-dev.sh`** — A development startup script that runs migrations and seeds for all services.

Each module's Prisma schema defines only the tables it owns. Its `PrismaService` connects to its own database via the `DATABASE_URL` environment variable. The module has no awareness of other modules' data models or database schemas.

## 3. Rules

1. **One database per module.** Every module that persists data has a dedicated PostgreSQL database. The database name is specified in the service registry's `database` field.
2. **Database names in snake_case.** Database names follow the convention of converting the service's kebab-case name to `snake_case` (e.g., `tax-billing-instalment` → `tax_billing_instalment`, `assessment-roll` → `assessment_roll`).
3. **Service registry is the single source of truth.** The `database` field in `products/<product>/infra/service-registry.ts` defines the database name. All generated infrastructure files derive from this registry — never edit `init-databases.sql` or `docker-compose.yml` database configs manually.
4. **`init-databases.sql` is auto-generated.** This SQL file is regenerated by `infra/generate.ts` whenever the service registry changes. It contains `CREATE DATABASE` and `GRANT ALL PRIVILEGES` statements for every module that has a non-empty `database` field.
5. **`DATABASE_URL` per service.** Each service receives its own `DATABASE_URL` environment variable in the format: `postgresql://<user>:<password>@<host>:<port>/<database_name>`. This is the only connection string the module's `PrismaService` uses.
6. **No cross-database queries.** A module must never execute SQL queries against another module's database. Cross-module data is fetched via HTTP service clients (REST APIs), defined in the service's `extraEnv` dependencies.
7. **Independent migrations.** Each module runs its own Prisma migrations against its own database. Migrations are scoped to the module's schema and do not affect other modules.
8. **Stateless services without a database.** Services that don't need persistence (e.g., API Gateway) set `database: ""` in the service registry and do not have a Prisma schema, PrismaService, or migrations.
9. **Single Postgres instance in dev, separate in prod.** Development uses one PostgreSQL 16 container with multiple databases via `init-databases.sql`. Production can use separate database instances per service for maximum isolation.
10. **Service dependencies via `extraEnv`.** When a service needs data from another service, it declares the dependency's URL in `extraEnv` (e.g., `ASSESSMENT_ROLL_URL: "http://assessment-roll:4104"`). The consuming service uses an HTTP client to call the producing service's API.
11. **Layer organization.** Services are organized into layers: `platform` (auth, notifications, audit), `shared` (billing, API gateway), and `domain` (tax-specific business modules). Each layer can have multiple services, each with its own database.
12. **Docker networking.** All services communicate over a Docker network using hostnames from the service registry. The PostgreSQL container uses the hostname `postgres` and connects to port `5432` inside the Docker network.

## 4. Structure

```
products/property-tax/
├── infra/
│   ├── service-registry.ts     # Single source of truth for all services
│   ├── generate.ts             # Generates infra files from registry
│   └── init-databases.sql      # Auto-generated: CREATE DATABASE per service
├── docker-compose.yml          # Service definitions with DATABASE_URL per service
└── start-dev.sh                # Runs migrations + seeds for all services

modules/
├── platform/
│   ├── auth-gateway/           # DB: auth_gateway
│   │   ├── prisma/schema.prisma
│   │   └── src/prisma.service.ts
│   ├── notification-engine/    # DB: notification_engine
│   └── audit-logging/          # DB: audit_logging
├── shared/
│   ├── billing-invoicing/      # DB: billing_invoicing
│   └── api-gateway/            # DB: (none — stateless proxy)
└── domain/
    └── revenue/
        ├── assessment-roll/    # DB: assessment_roll
        ├── tax-billing-instalment/ # DB: tax_billing_instalment
        ├── tax-levy-rate/      # DB: tax_levy_rate
        ├── payment-processing/ # DB: payment_processing
        ├── tax-certificates/   # DB: tax_certificates
        └── tax-sale-proceedings/ # DB: tax_sale_proceedings
```

**Data flow between services (never direct DB access):**

```
┌─────────────────┐       HTTP/REST        ┌─────────────────┐
│  Tax Billing &   │ ───────────────────── │  Assessment      │
│  Instalment      │  GET /api/v1/properties│  Roll            │
│                  │ ◄───────────────────── │                  │
│  DB: tax_billing │        JSON            │  DB: assessment  │
│  _instalment     │                        │  _roll           │
└─────────────────┘                        └─────────────────┘
       │                                           │
       │ Own DB only                               │ Own DB only
       ▼                                           ▼
  ┌──────────┐                               ┌──────────┐
  │ PostgreSQL│                               │ PostgreSQL│
  │ tax_billing│                              │ assessment│
  │ _instalment│                              │ _roll     │
  └──────────┘                               └──────────┘
```

## 5. Example Implementation

**Service Registry entry (`infra/service-registry.ts`):**

```typescript
/**
 * ─── Service Registry — Single Source of Truth ──────────────
 *
 * Every microservice, its port, database name, Dockerfile path,
 * and API route prefixes are defined here ONCE.
 *
 * Generated artifacts:
 *   • apps/property-tax-web/nginx.conf
 *   • products/property-tax/infra/init-databases.sql
 *   • products/property-tax/start-dev.sh
 *
 * Run:  pnpm tsx infra/generate.ts
 */

export interface ServiceDefinition {
    /** Docker Compose service name (used as hostname in the Docker network) */
    readonly hostname: string;
    /** Internal port the NestJS app listens on */
    readonly port: number;
    /** PostgreSQL database name (snake_case) — empty string for stateless services */
    readonly database: string;
    /** Path to Dockerfile relative to monorepo root */
    readonly dockerfile: string;
    /** API route prefixes this service handles (without trailing slash) */
    readonly routes: readonly string[];
    /** Layer for documentation / ordering */
    readonly layer: "platform" | "shared" | "domain";
    /** Human-readable label */
    readonly label: string;
    /** Extra env vars beyond the shared ones */
    readonly extraEnv?: Readonly<Record<string, string>>;
    /** Services this service depends on (by registry key) */
    readonly dependsOn?: readonly string[];
    /** Whether the service needs Redis */
    readonly needsRedis?: boolean;
}

const serviceRegistry = {
    // ── Platform Layer ───────────────────────────────────────
    "auth-gateway": {
        hostname: "auth-gateway",
        port: 4100,
        database: "auth_gateway",
        dockerfile: "modules/platform/auth-gateway/Dockerfile",
        layer: "platform" as const,
        label: "Auth Gateway",
        needsRedis: true,
        routes: ["/api/v1/auth", "/api/v1/users"],
    },
    "notification-engine": {
        hostname: "notification-engine",
        port: 4101,
        database: "notification_engine",
        dockerfile: "modules/platform/notification-engine/Dockerfile",
        layer: "platform" as const,
        label: "Notification Engine",
        routes: ["/api/v1/notifications", "/api/v1/templates"],
    },
    "audit-logging": {
        hostname: "audit-logging",
        port: 4300,
        database: "audit_logging",
        dockerfile: "modules/platform/audit-logging/Dockerfile",
        layer: "platform" as const,
        label: "Audit Logging",
        routes: ["/api/v1/audit-logs"],
    },

    // ── Shared Layer ────────────────────────────────────────
    "api-gateway": {
        hostname: "api-gateway",
        port: 4110,
        database: "", // ← No database (stateless proxy)
        dockerfile: "modules/shared/api-gateway/Dockerfile",
        layer: "shared" as const,
        label: "API Gateway",
        routes: ["/api/v1/citizen-portal"],
        dependsOn: ["auth-gateway", "assessment-roll", "tax-billing-instalment"],
        extraEnv: {
            AUTH_GATEWAY_URL: "http://auth-gateway:4100",
            ASSESSMENT_ROLL_URL: "http://assessment-roll:4104",
            TAX_BILLING_URL: "http://tax-billing-instalment:4103",
        },
    },

    // ── Domain Layer (Revenue) ──────────────────────────────
    "assessment-roll": {
        hostname: "assessment-roll",
        port: 4104,
        database: "assessment_roll",
        dockerfile: "modules/domain/revenue/assessment-roll/Dockerfile",
        layer: "domain" as const,
        label: "Assessment Roll",
        routes: ["/api/v1/properties", "/api/v1/assessments", "/api/v1/owners"],
    },
    "tax-billing-instalment": {
        hostname: "tax-billing-instalment",
        port: 4103,
        database: "tax_billing_instalment",
        dockerfile: "modules/domain/revenue/tax-billing-instalment/Dockerfile",
        layer: "domain" as const,
        label: "Tax Billing & Instalment",
        routes: ["/api/v1/tax-bills", "/api/v1/instalments"],
        dependsOn: ["assessment-roll"],
        extraEnv: {
            ASSESSMENT_ROLL_URL: "http://assessment-roll:4104",
        },
    },
} satisfies Record<string, ServiceDefinition>;

export type ServiceKey = keyof typeof serviceRegistry;
export { serviceRegistry };
```

**Auto-generated `init-databases.sql`:**

```sql
-- ─── Property Tax Product — Database Initialization ─────────
-- AUTO-GENERATED by infra/generate.ts — do not edit manually.
-- Source of truth: products/property-tax/infra/service-registry.ts
--
-- Creates one database per module (DB-per-service pattern)

CREATE DATABASE auth_gateway;
CREATE DATABASE notification_engine;
CREATE DATABASE audit_logging;
CREATE DATABASE billing_invoicing;
CREATE DATABASE tax_billing_instalment;
CREATE DATABASE assessment_roll;
CREATE DATABASE tax_levy_rate;
CREATE DATABASE payment_processing;
CREATE DATABASE tax_certificates;
CREATE DATABASE tax_sale_proceedings;

-- Grant full access to the civic user
GRANT ALL PRIVILEGES ON DATABASE auth_gateway TO civic;
GRANT ALL PRIVILEGES ON DATABASE notification_engine TO civic;
GRANT ALL PRIVILEGES ON DATABASE audit_logging TO civic;
GRANT ALL PRIVILEGES ON DATABASE billing_invoicing TO civic;
GRANT ALL PRIVILEGES ON DATABASE tax_billing_instalment TO civic;
GRANT ALL PRIVILEGES ON DATABASE assessment_roll TO civic;
GRANT ALL PRIVILEGES ON DATABASE tax_levy_rate TO civic;
GRANT ALL PRIVILEGES ON DATABASE payment_processing TO civic;
GRANT ALL PRIVILEGES ON DATABASE tax_certificates TO civic;
GRANT ALL PRIVILEGES ON DATABASE tax_sale_proceedings TO civic;
```

**Docker Compose service definition with `DATABASE_URL` (excerpt from `docker-compose.yml`):**

```yaml
services:
    # ─── Infrastructure ────────────────────────────
    postgres:
        image: postgres:16-alpine
        restart: unless-stopped
        environment:
            POSTGRES_USER: ${POSTGRES_USER:-civic}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
            POSTGRES_DB: ${POSTGRES_DB:-civic_platform}
        ports:
            - "5433:5432"
        volumes:
            - postgres_data:/var/lib/postgresql/data
            - ./init-databases.sql:/docker-entrypoint-initdb.d/01-init.sql
        healthcheck:
            test: ["CMD-SHELL", "pg_isready -U civic"]
            interval: 5s
            timeout: 3s
            retries: 5

    # ─── Domain Services ──────────────────────────
    assessment-roll:
        build:
            context: ../../
            dockerfile: modules/domain/revenue/assessment-roll/Dockerfile
        environment:
            PORT: 4104
            NODE_ENV: development
            DATABASE_URL: postgresql://civic:${POSTGRES_PASSWORD}@postgres:5432/assessment_roll
            RABBITMQ_URL: amqp://civic:${RABBITMQ_DEFAULT_PASS}@rabbitmq:5672/property-tax
            JWT_SECRET: ${JWT_SECRET}
        depends_on:
            postgres:
                condition: service_healthy
            rabbitmq:
                condition: service_healthy

    tax-billing-instalment:
        build:
            context: ../../
            dockerfile: modules/domain/revenue/tax-billing-instalment/Dockerfile
        environment:
            PORT: 4103
            NODE_ENV: development
            DATABASE_URL: postgresql://civic:${POSTGRES_PASSWORD}@postgres:5432/tax_billing_instalment
            RABBITMQ_URL: amqp://civic:${RABBITMQ_DEFAULT_PASS}@rabbitmq:5672/property-tax
            JWT_SECRET: ${JWT_SECRET}
            ASSESSMENT_ROLL_URL: http://assessment-roll:4104
        depends_on:
            postgres:
                condition: service_healthy
            assessment-roll:
                condition: service_started
```

**Infrastructure generator (`infra/generate.ts`) — database SQL generation excerpt:**

```typescript
import { serviceRegistry } from "./service-registry";

function generateInitDatabasesSql(): string {
    const databases = Object.values(serviceRegistry)
        .filter((svc) => svc.database.length > 0)
        .map((svc) => svc.database);

    const creates = databases.map((db) => `CREATE DATABASE ${db};`).join("\n");
    const grants = databases
        .map((db) => `GRANT ALL PRIVILEGES ON DATABASE ${db} TO civic;`)
        .join("\n");

    return [
        "-- ─── Property Tax Product — Database Initialization ─────────",
        "-- AUTO-GENERATED by infra/generate.ts — do not edit manually.",
        "-- Source of truth: products/property-tax/infra/service-registry.ts",
        "--",
        "-- Creates one database per module (DB-per-service pattern)",
        "",
        creates,
        "",
        "-- Grant full access to the civic user",
        grants,
        "",
    ].join("\n");
}
```

**Key observations from the example:**

- The `database` field in the service registry dictates the PostgreSQL database name. Services without a database (like `api-gateway`) set `database: ""`.
- The `init-databases.sql` is auto-generated and mounted as a Docker entrypoint script. PostgreSQL executes it once on first startup, creating all databases.
- Each service's `DATABASE_URL` in Docker Compose points to its own specific database on the shared PostgreSQL instance: `postgresql://civic:password@postgres:5432/<database_name>`.
- Cross-service communication uses `extraEnv` URLs (e.g., `ASSESSMENT_ROLL_URL`). The consuming service never queries the producing service's database directly.
- The `dependsOn` field in both Docker Compose and the service registry ensures services start in the correct order and database dependencies are respected.
- In production, each `DATABASE_URL` would point to a separate PostgreSQL instance, but the code (PrismaService, repositories) remains identical — only the connection string changes.
