# Prisma Schema Design

## 1. Component Pattern

**Type:** Database Schema Definition  
**Layer:** Data / Persistence  
**Reference Implementation:** `modules/domain/revenue/assessment-roll/prisma/schema.prisma`

## 2. Overview

Every microservice module defines its own Prisma schema at `prisma/schema.prisma` relative to the module root. The schema is the single source of truth for the module's database structure — it defines every table, column, enum, relation, and index. Prisma Migrate generates SQL migrations from this file, and the Prisma Client generator produces a fully-typed query builder scoped to the module.

The generator outputs the client to `../generated/prisma` (local to the module, never a shared package). The datasource specifies `provider = "postgresql"` but omits the connection URL — this is injected at runtime via the `DATABASE_URL` environment variable, following the database-per-service architecture where each module owns its own PostgreSQL database.

All models share a consistent field pattern: UUID primary keys, audit tracking fields (`createdBy`, `updatedBy`, `createdAt`, `updatedAt`), and soft-delete support via a nullable `deletedAt` timestamp. Monetary values are stored as `BigInt` in cents (not `Decimal`) to avoid floating-point precision issues. Measurement fields use `@db.Decimal(precision, scale)` for exactness. Enums are defined natively in Prisma (not in TypeScript) so they are enforced at the database level.

Relations always specify `onDelete` behavior (typically `Cascade`). Business-key uniqueness constraints use `@@unique()`. Performance-critical query paths are indexed with `@@index()`. Table names are mapped to snake_case using `@@map()`.

## 3. Rules

1. **Generator output is module-local.** Always set `output = "../generated/prisma"` so each module has its own isolated Prisma Client. Never share a generated client across modules.
2. **No URL in datasource.** The `datasource db` block specifies only `provider = "postgresql"`. The connection URL is provided at runtime via `DATABASE_URL` environment variable.
3. **UUID primary keys.** Every model must have `id String @id @default(uuid()) @db.Uuid` as its first field.
4. **Audit fields on every model.** Include `createdBy String @db.Uuid`, `updatedBy String @db.Uuid`, `createdAt DateTime @default(now())`, and `updatedAt DateTime @updatedAt` on every model without exception.
5. **Soft delete on every model.** Include `deletedAt DateTime?` on every model. Records are never physically deleted — they are marked with a `deletedAt` timestamp.
6. **Money in cents as BigInt.** All monetary values are stored as `BigInt` representing cents (e.g., `currentValueCents BigInt`). Never use `Decimal` or `Float` for money. Convert to dollars/display format only at the API boundary.
7. **Decimals for measurements.** Physical measurements (metres, percentages, acreage) use `Decimal` with an explicit `@db.Decimal(precision, scale)` annotation (e.g., `@db.Decimal(10, 2)` for metres, `@db.Decimal(5, 2)` for percentages).
8. **Enums defined in Prisma.** All enum types are declared in the Prisma schema (not in TypeScript files) so they are created as native PostgreSQL enums via migration. Enum values use UPPER_SNAKE_CASE.
9. **Explicit relation config.** All relations must specify `@relation(fields: [foreignKeyField], references: [id], onDelete: Cascade)` (or the appropriate `onDelete` behavior). Never rely on Prisma's implicit relation inference.
10. **Index frequently queried columns.** Add `@@index()` on columns commonly used in `WHERE`, `ORDER BY`, or `JOIN` clauses — especially `status`, foreign key fields, year fields, and date fields.
11. **Business-key uniqueness.** Use `@@unique()` for compound uniqueness constraints that represent business rules (e.g., `@@unique([propertyId, assessmentYear, rollType])` — one assessment per property per year per roll type).
12. **Snake_case table names.** Every model uses `@@map("snake_case_table_name")` to produce PostgreSQL-conventional table names. The Prisma model name remains PascalCase.
13. **Optional fields use `?`.** Fields that may be absent are typed with `?` (e.g., `description String?`, `endDate DateTime?`). Required fields never have `?`.
14. **Default values where appropriate.** Use `@default()` for sensible defaults: `@default(0)` for counters, `@default(now())` for timestamps, `@default(ACTIVE)` for status enums, `@default("ON")` for province fields.
15. **One schema per module.** Each module maintains its own `prisma/schema.prisma`. Cross-module data access is never done via shared schemas — it is handled via HTTP service clients.

## 4. Structure

```
modules/domain/<domain>/<module>/
├── prisma/
│   ├── schema.prisma           # Schema definition (this pattern)
│   ├── seed.ts                 # Seed data script
│   └── migrations/             # Auto-generated by `prisma migrate dev`
│       ├── 20250101000000_init/
│       │   └── migration.sql
│       └── migration_lock.toml
├── generated/
│   └── prisma/                 # Auto-generated Prisma Client (git-ignored)
│       ├── index.ts
│       ├── client.ts
│       └── ...
└── src/
    ├── prisma.service.ts       # NestJS wrapper around the generated client
    └── repositories/           # Data access layer using the client
```

**Schema block ordering convention:**

```
1. generator client { ... }
2. datasource db { ... }
3. Models (grouped by domain concept, each followed by related child models)
4. Enums (grouped after all models, in the order they are referenced)
```

**Field ordering convention within a model:**

```
1. id                           # Primary key (always first)
2. Foreign key fields           # e.g., propertyId, ownerId
3. Business fields              # e.g., name, code, rollNumber
4. Status / type enums          # e.g., status, type
5. Monetary fields              # e.g., amountCents, valueCents
6. Measurement fields           # e.g., frontageMetres, acreage
7. Optional / nullable fields   # e.g., description?, notes?
8. Audit fields                 # createdBy, updatedBy, createdAt, updatedAt
9. Soft delete field             # deletedAt
10. Relations                   # parent, children, items (after all scalar fields)
11. @@index / @@unique / @@map  # Block-level attributes (always last)
```

## 5. Example Implementation

```prisma
// ─── Resource Management Database Schema ────────────────────
// Domain module — resource tracking, categorization, and lifecycle.
//
// Database topology: 1 database per module (DB-per-service)
//   DB:  resource_management
//   URL: postgresql://.../resource_management

generator client {
    provider = "prisma-client"
    output   = "../generated/prisma"
}

datasource db {
    provider = "postgresql"
}

// ─── Models ─────────────────────────────────────────────────

model Resource {
    id String @id @default(uuid()) @db.Uuid

    categoryId     String          @db.Uuid
    name           String
    code           String          @unique
    legalReference String?
    description    String?
    type           ResourceType
    status         ResourceStatus  @default(ACTIVE)
    priority       ResourcePriority @default(NORMAL)
    valueCents     BigInt          @default(0)
    weightKg       Decimal?        @db.Decimal(10, 2)
    lengthMetres   Decimal?        @db.Decimal(10, 2)
    areaHectares   Decimal?        @db.Decimal(10, 4)
    ward           String?
    zone           String?
    notes          String?
    metadata       Json?
    parentId       String?         @db.Uuid
    createdBy      String          @db.Uuid
    updatedBy      String          @db.Uuid
    createdAt      DateTime        @default(now())
    updatedAt      DateTime        @updatedAt
    deletedAt      DateTime?

    category    Category     @relation(fields: [categoryId], references: [id])
    parent      Resource?    @relation("ResourceHierarchy", fields: [parentId], references: [id])
    children    Resource[]   @relation("ResourceHierarchy")
    assignments Assignment[]
    audits      AuditEntry[]
    tags        ResourceTag[]

    @@index([categoryId])
    @@index([type])
    @@index([status])
    @@index([parentId])
    @@index([ward])
    @@map("resources")
}

model Category {
    id String @id @default(uuid()) @db.Uuid

    name        String          @unique
    code        String          @unique
    description String?
    sortOrder   Int             @default(0)
    isActive    Boolean         @default(true)
    createdBy   String          @db.Uuid
    updatedBy   String          @db.Uuid
    createdAt   DateTime        @default(now())
    updatedAt   DateTime        @updatedAt
    deletedAt   DateTime?

    resources Resource[]

    @@map("categories")
}

model Assignment {
    id String @id @default(uuid()) @db.Uuid

    resourceId       String           @db.Uuid
    assigneeId       String           @db.Uuid
    assignmentType   AssignmentType
    status           AssignmentStatus @default(ACTIVE)
    effectiveDate    DateTime         @default(now())
    endDate          DateTime?
    allocationPct    Decimal          @default(100) @db.Decimal(5, 2)
    notes            String?
    createdBy        String           @db.Uuid
    updatedBy        String           @db.Uuid
    createdAt        DateTime         @default(now())
    updatedAt        DateTime         @updatedAt
    deletedAt        DateTime?

    resource Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

    @@unique([resourceId, assigneeId, assignmentType])
    @@index([resourceId])
    @@index([assigneeId])
    @@index([status])
    @@map("assignments")
}

model AuditEntry {
    id String @id @default(uuid()) @db.Uuid

    resourceId  String    @db.Uuid
    action      String
    fieldName   String?
    oldValue    String?
    newValue    String?
    changedBy   String    @db.Uuid
    changedAt   DateTime  @default(now())
    createdBy   String    @db.Uuid
    updatedBy   String    @db.Uuid
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    deletedAt   DateTime?

    resource Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

    @@index([resourceId])
    @@index([changedAt])
    @@map("audit_entries")
}

model ResourceTag {
    id String @id @default(uuid()) @db.Uuid

    resourceId String @db.Uuid
    tag        String
    createdBy  String @db.Uuid
    updatedBy  String @db.Uuid
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt
    deletedAt  DateTime?

    resource Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

    @@unique([resourceId, tag])
    @@index([tag])
    @@map("resource_tags")
}

// ─── Enums ──────────────────────────────────────────────────

enum ResourceType {
    INFRASTRUCTURE
    EQUIPMENT
    VEHICLE
    PROPERTY
    NATURAL
    DIGITAL
}

enum ResourceStatus {
    ACTIVE
    INACTIVE
    UNDER_REVIEW
    DECOMMISSIONED
}

enum ResourcePriority {
    LOW
    NORMAL
    HIGH
    CRITICAL
}

enum AssignmentType {
    PRIMARY
    SECONDARY
    TEMPORARY
    BACKUP
}

enum AssignmentStatus {
    ACTIVE
    SUSPENDED
    COMPLETED
    CANCELLED
}
```

**Key observations from the example:**

- The generator outputs to `../generated/prisma` — a directory within the module, not a shared workspace package.
- The datasource has no `url` — the `DATABASE_URL` env var is injected at runtime by the NestJS `PrismaService` or by Prisma CLI when running migrations.
- Every model follows the exact same field order: `id` → foreign keys → business fields → enums → money/measurements → optional fields → audit fields → `deletedAt` → relations → block attributes.
- Money fields (`valueCents`) use `BigInt`, while physical measurements (`weightKg`, `lengthMetres`, `areaHectares`) use `Decimal` with explicit `@db.Decimal()`.
- Self-referential relations (`parent`/`children`) use a named relation string (`"ResourceHierarchy"`) to disambiguate.
- `@@unique([resourceId, assigneeId, assignmentType])` enforces the business rule: one assignment per type per person per resource.
- `@@map("snake_case")` on every model ensures PostgreSQL table names follow database conventions while Prisma model names remain PascalCase.
- Enums are grouped at the end of the file and use UPPER_SNAKE_CASE values. They are declared in Prisma, not in TypeScript.
